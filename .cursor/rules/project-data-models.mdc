---
alwaysApply: true
---
## ðŸ”— Model Relationships

### **One-to-Many Relationships**
- **User â†’ Businesses**: One user can own multiple businesses
- **Category â†’ Services**: One category can have multiple services
- **Category â†’ Businesses**: One category can have multiple businesses
- **Category â†’ Subcategories**: One category can have multiple subcategories

### **Many-to-Many Relationships**
- **Business â†” Services**: Businesses can offer multiple services
- **User â†” Business (Favorites)**: Users can favorite multiple businesses
- **User â†” Business (Feedback)**: Users can rate multiple businesses

### **Referential Integrity**
```javascript
// Business deletion cascade
businessSchema.pre('remove', async function(next) {
  try {
    await this.model('Favorite').deleteMany({ businessId: this._id });
    await this.model('Feedback').deleteMany({ businessId: this._id });
    next();
  } catch (error) {
    next(error);
  }
});

// Category deletion check
categorySchema.pre('remove', async function(next) {
  try {
    const businessCount = await this.model('Business').countDocuments({ categoryId: this._id });
    if (businessCount > 0) {
      return next(new Error('Cannot delete category with existing businesses'));
    }
    next();
  } catch (error) {
    next(error);
  }
});

// User deletion check
userSchema.pre('remove', async function(next) {
  try {
    const businessCount = await this.model('Business').countDocuments({ userId: this._id });
    if (businessCount > 0) {
      return next(new Error('Cannot delete user with existing businesses'));
    }
    next();
  } catch (error) {
    next(error);
  }
});

// Update business count when business is created/updated/deleted
businessSchema.post('save', async function() {
  if (this.categoryId) {
    const Category = this.model('Category');
    const count = await this.model('Business').countDocuments({ 
      categoryId: this.categoryId, 
      active: true, 
      approved: true 
    });
    await Category.findByIdAndUpdate(this.categoryId, { businessCount: count });
  }
});

// Update service count when business services change
businessSchema.post('save', async function() {
  if (this.services && this.services.length > 0) {
    const Service = this.model('Service');
    for (const service of this.services) {
      if (service.serviceId) {
        const count = await this.model('Business').countDocuments({ 
          'services.serviceId': service.serviceId,
          active: true, 
          approved: true 
        });
        await Service.findByIdAndUpdate(service.serviceId, { businessCount: count });
      }
    }
  }
});
```

---

## ðŸ“Š Database Indexes

### **Performance Indexes**
```javascript
// Text search indexes
businessSchema.index({ name: 'text', description: 'text' });
categorySchema.index({ name: 'text' });
serviceSchema.index({ name: 'text' });

// Geospatial indexes
businessSchema.index({ location: '2dsphere' });

// Compound indexes for common queries
businessSchema.index({ categoryId: 1, active: 1, approved: 1 });
businessSchema.index({ userId: 1, active: 1 });
businessSchema.index({ rating: -1, active: 1, approved: 1 });
businessSchema.index({ location: '2dsphere', categoryId: 1 });
businessSchema.index({ createdAt: -1, active: 1, approved: 1 });
businessSchema.index({ featured: 1, active: 1, approved: 1 });
businessSchema.index({ city: 1, active: 1, approved: 1 });
businessSchema.index({ verified: 1, active: 1, approved: 1 });
businessSchema.index({ viewCount: -1, active: 1, approved: 1 });
businessSchema.index({ favoriteCount: -1, active: 1, approved: 1 });

// User indexes
userSchema.index({ email: 1 });
userSchema.index({ authProvider: 1, providerId: 1 });
userSchema.index({ role: 1 });
userSchema.index({ is_verified: 1 });
userSchema.index({ 'preferences.language': 1 });
userSchema.index({ createdAt: -1 });
userSchema.index({ last_login: -1 });

// Feedback indexes
feedbackSchema.index({ businessId: 1, approved: 1, createdAt: -1 });
feedbackSchema.index({ userId: 1, businessId: 1 }, { unique: true });
feedbackSchema.index({ approved: 1 });
feedbackSchema.index({ rating: 1, approved: 1 });
feedbackSchema.index({ reported: 1, approved: 1 });

// Favorite indexes
favoriteSchema.index({ userId: 1, businessId: 1 }, { unique: true });
favoriteSchema.index({ userId: 1, createdAt: -1 });
favoriteSchema.index({ businessId: 1, createdAt: -1 });

// Category indexes
categorySchema.index({ active: 1, sortOrder: 1, name: 1 });
categorySchema.index({ name: 'text' });
categorySchema.index({ parentId: 1, active: 1 });
categorySchema.index({ businessCount: -1, active: 1 });

// Service indexes
serviceSchema.index({ categoryId: 1, active: 1 });
serviceSchema.index({ name: 'text' });
serviceSchema.index({ active: 1, sortOrder: 1 });
serviceSchema.index({ businessCount: -1, active: 1 });

// Suggestion indexes
suggestionSchema.index({ status: 1, createdAt: -1 });
suggestionSchema.index({ suggestedBy: 1 });
suggestionSchema.index({ type: 1, status: 1 });
suggestionSchema.index({ categoryId: 1, status: 1 });
suggestionSchema.index({ submitterEmail: 1 });
```

### **Query Optimization Patterns**
```javascript
// 1. Find businesses by category and location (nearby search)
businessSchema.index({ categoryId: 1, location: '2dsphere' });

// 2. Find top-rated businesses (featured businesses)
businessSchema.index({ rating: -1, active: 1, approved: 1 });

// 3. Find user's businesses (user dashboard)
businessSchema.index({ userId: 1, active: 1 });

// 4. Find user's favorites (favorites page)
favoriteSchema.index({ userId: 1, createdAt: -1 });

// 5. Find business reviews (business profile)
feedbackSchema.index({ businessId: 1, approved: 1, createdAt: -1 });

// 6. Find categories for navigation
categorySchema.index({ active: 1, sortOrder: 1 });

// 7. Find services by category (filtering)
serviceSchema.index({ categoryId: 1, active: 1 });

// 8. Find pending suggestions (admin panel)
suggestionSchema.index({ status: 1, createdAt: -1 });

// 9. Find users by role (admin panel)
userSchema.index({ role: 1, createdAt: -1 });

// 10. Find businesses by creation date (new businesses)
businessSchema.index({ createdAt: -1, active: 1, approved: 1 });

// 11. Find featured businesses (homepage)
businessSchema.index({ featured: 1, active: 1, approved: 1 });

// 12. Find businesses by city (local search)
businessSchema.index({ city: 1, active: 1, approved: 1 });

// 13. Find verified businesses (trusted businesses)
businessSchema.index({ verified: 1, active: 1, approved: 1 });

// 14. Find most viewed businesses (popular businesses)
businessSchema.index({ viewCount: -1, active: 1, approved: 1 });

// 15. Find most favorited businesses (trending businesses)
businessSchema.index({ favoriteCount: -1, active: 1, approved: 1 });
```

### **Index Performance Monitoring**
```javascript
// Monitor index usage
db.businesses.getIndexes();
db.businesses.aggregate([
  { $indexStats: {} }
]);

// Check query performance
db.businesses.find({ categoryId: ObjectId("...") }).explain("executionStats");

// Monitor index size and usage
db.businesses.stats().indexSizes;
```

---

## ðŸ”’ Data Validation

### **Schema Validation Rules**
```javascript
// Email validation
email: {
  type: String,
  required: true,
  lowercase: true,
  trim: true,
  validate: {
    validator: function(v) {
      return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v);
    },
    message: 'Invalid email format'
  }
}

// Phone validation
phone: {
  type: String,
  required: true,
  validate: {
    validator: function(v) {
      return /^[0-9+\-\s()]+$/.test(v);
    },
    message: 'Invalid phone format'
  }
}

// URL validation
logo: {
  type: String,
  validate: {
    validator: function(v) {
      return !v || /^https?:\/\/.+/.test(v);
    },
    message: 'Invalid URL format'
  }
}

// Password validation
password: {
  type: String,
  required: function() { return this.authProvider === 'local'; },
  minlength: 8,
  validate: {
    validator: function(v) {
      return /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/.test(v);
    },
    message: 'Password must contain at least 8 characters, one uppercase, one lowercase, one number and one special character'
  }
}
```

### **Custom Validators**
```javascript
// Business hours validation
openingHours: {
  validate: {
    validator: function(hours) {
      return hours.length === 7; // All days must be defined
    },
    message: 'All 7 days must be defined'
  }
}

// Rating calculation
businessSchema.methods.updateRating = async function() {
  const feedback = await this.model('Feedback').find({ 
    businessId: this._id, 
    approved: true 
  });
  
  if (feedback.length > 0) {
    const avgRating = feedback.reduce((sum, f) => sum + f.rating, 0) / feedback.length;
    this.rating = Math.round(avgRating * 10) / 10; // Round to 1 decimal
    this.totalRatings = feedback.length;
    
    // Calculate rating distribution
    const distribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
    feedback.forEach(review => {
      distribution[review.rating]++;
    });
    this.ratingDistribution = distribution;
  } else {
    this.rating = 0;
    this.totalRatings = 0;
    this.ratingDistribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
  }
  
  await this.save();
};

// Update business statistics
businessSchema.methods.updateStatistics = async function() {
  const [favoriteCount, reviewCount] = await Promise.all([
    this.model('Favorite').countDocuments({ businessId: this._id }),
    this.model('Feedback').countDocuments({ businessId: this._id, approved: true })
  ]);
  
  this.favoriteCount = favoriteCount;
  this.reviewCount = reviewCount;
  await this.save();
};
```

---

## ðŸ“ˆ Data Analytics

### **Aggregation Pipelines**
```javascript
// Business statistics by category
const businessStats = await Business.aggregate([
  { $match: { active: true, approved: true } },
  { $group: {
    _id: '$categoryId',
    count: { $sum: 1 },
    avgRating: { $avg: '$rating' },
    totalViews: { $sum: '$viewCount' },
    totalFavorites: { $sum: '$favoriteCount' }
  }},
  { $lookup: {
    from: 'categories',
    localField: '_id',
    foreignField: '_id',
    as: 'category'
  }},
  { $unwind: '$category' },
  { $sort: { count: -1 } }
]);

// User activity and engagement
const userActivity = await User.aggregate([
  { $lookup: {
    from: 'businesses',
    localField: '_id',
    foreignField: 'userId',
    as: 'businesses'
  }},
  { $lookup: {
    from: 'favorites',
    localField: '_id',
    foreignField: 'userId',
    as: 'favorites'
  }},
  { $lookup: {
    from: 'feedback',
    localField: '_id',
    foreignField: 'userId',
    as: 'reviews'
  }},
  { $project: {
    email: 1,
    firstName: 1,
    lastName: 1,
    role: 1,
    businessCount: { $size: '$businesses' },
    favoriteCount: { $size: '$favorites' },
    reviewCount: { $size: '$reviews' },
    lastActivity: { 
      $max: [
        '$updatedAt', 
        { $max: '$businesses.updatedAt' },
        { $max: '$favorites.createdAt' },
        { $max: '$reviews.createdAt' }
      ] 
    }
  }}
]);

// Popular categories and services
const popularCategories = await Category.aggregate([
  { $match: { active: true } },
  { $lookup: {
    from: 'businesses',
    localField: '_id',
    foreignField: 'categoryId',
    as: 'businesses'
  }},
  { $project: {
    name: 1,
    nameEn: 1,
    businessCount: { $size: '$businesses' },
    avgRating: { $avg: '$businesses.rating' },
    totalViews: { $sum: '$businesses.viewCount' }
  }},
  { $sort: { businessCount: -1 } }
]);

// Review analytics
const reviewAnalytics = await Feedback.aggregate([
  { $match: { approved: true } },
  { $group: {
    _id: '$rating',
    count: { $sum: 1 },
    avgHelpfulVotes: { $avg: '$helpfulVotes' }
  }},
  { $sort: { _id: 1 } }
]);
```


